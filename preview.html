<!--
Copyright Chris Singendonk 2023
All Rights Reserved
-->
<!DOCTYPE html>
<html>

<head>
  <meta name="author" content="Chris Singendonk"/>
</head>

<body>
    <script>
      const author = `Chris Singendonk`;
      const copyright = `2023`;
if (!window.APIChatBox){
const createCustomSelectInput = (add = true) => {
    if (!customElements.get('combo-input')) {
        add = false;
    }
    class CustomSelectInput extends HTMLElement {
            constructor() {
                super();
                this.#shadow = this.attachShadow({ mode: 'closed' });
                this.state = {
                    value: '',
                    options: [],
                    placeholder: '',
                    selectionMode: 'single'
                };
                this.textbox = this.#textbox;
                this.dropdown = this.#dropdown;
                this.announcementRegion = null;
            }

            #textbox = (() => { return this.textbox; })();
            #dropdown = (() => { return this.dropdown; })();

            static get observedAttributes() {
                return ['data-placeholder', 'data-options', 'data-value', 'data-selection-mode'];
            }
            #shadow;
            connectedCallback() {
                this.#render();
                this.#initializeState();
                this.#initializeAttributes();
                this.#setupEventListeners();
            }

            disconnectedCallback() {
                this.#cleanupEventListeners();
            }

            attributeChangedCallback(name, oldValue, newValue) {
                if (oldValue === newValue || (!oldValue || !newValue || !name) || (name != 'data-options' || name != 'data-placeholder' || name != "data-value" || name != 'data-selection-mode')) return;
                const handlers = {
                    'data-value': () => this.#updateValue(newValue),
                    'data-options': () => {
                        this.state.options = this.#parseOptions(newValue);
                        this.#syncOptionsWithSelect();
                    },
                    'data-placeholder': () => this.#updatePlaceholder(newValue),
                    'data-selection-mode': () => this.#updateSelectionMode(newValue)
                };
                handlers[name]?.();
            }

            #initializeState() {
                this.#textbox = this.#shadow.querySelector('input');
                this.#dropdown = this.#shadow.querySelector('select');
                this.announcementRegion = document.querySelector('#announcement');
            }

            #initializeAttributes() {
                this.state.placeholder = this.getAttribute('data-placeholder') || 'Type/Select an option';
                this.state.options = this.#parseOptions(this.getAttribute('data-options'));
                this.state.value = this.getAttribute('data-value') || '';
                this.state.selectionMode = this.getAttribute('data-selection-mode') || 'single';
                this.#updateUI();
            }

            #setupEventListeners() {
                this.#textbox?.addEventListener('input', this.#handleTextInput.bind(this));
                this.#textbox?.addEventListener('keydown', this.#handleKeyPress.bind(this));
                this.#dropdown?.addEventListener('keydown', this.#handleTextInput.bind(this));
                this.#dropdown?.addEventListener('change', this.#handleSelectChange.bind(this));
                this.#dropdown?.addEventListener('focus', this.#handleFocus.apply(this));
            }

            #cleanupEventListeners() {
                this.#textbox?.removeEventListener('input', this.#handleTextInput);
                this.#textbox?.removeEventListener('keydown', this.#handleKeyPress);
                this.#dropdown?.removeEventListener('change', this.#handleSelectChange);
            }

            #render() {
                const template = `
    
    <style>
        :host {
            display: inline-block;
            width: 200px;
            height: 1.5rem;
            contain: strict;
            position: initial;
        }
        * {
            background-color: #282c34;
            color: #fff;
            font-family: 'Arial', sans-serif;
            font-size: 14px;
            line-height: 1.25rem;
            margin: 0;
            padding: 0;
            width: 100%;
            box-sizing: border-box;
            min-height: 1.5rem;
        }
        input, select {
            border: 1px solid #555;
            border-radius: 4px;
            padding: 0.25rem;
            position: absolute;
            left: 0;
            top: 0;
            float: left;
            position: relative;
            clear: none;
            z-index: 1;
        }
        select {
            width: fit-coontent;
            height: 2rem;
            max-height: 0px;
            overflow: hidden;
            z-index: 0;
        }
        input {
            width: 90%;
            z-index: 9999999999;
            position: absolute;
            float: left;
            clear: none;
            bottom: 0;
            right: 10%;
        }
        option {
            
        }

        div, div * {
            height: 100%;
        } 

        div {
            padding: 0px;
            min-height: 100%;
        }
            div:nth-child(2) > select:nth-child(1) {
            top: 0;
            bottom:0;
    border: initial;
    outline: initial;
    box-shadow: initial;
}

        
    </style>
    <div>
        <select style="top: 0px;"><option value=""></option><option value="fuck">fuck</option><option value="fuckit">fuckit</option><option value="it">]</option></select>
        <input type="text" placeholder="Type/Select an option" style="width: 90%;z-index: 9999999999;position: absolute;float: left;clear: none;bottom: 0;right: 10%;">
        
    </div>
`;
                this.#shadow.innerHTML = template;
                this.style.padding = '0px';

                this.#initializeState();
            }

            #updateUI() {
                this.#updatePlaceholder(this.state.placeholder);
                this.#updateValue(this.state.value || this.state.options[0]?.value || '');
                this.#syncOptionsWithSelect();
                this.#positionDropdown();
            }

            #updateSelectionMode(mode) {
                this.state.selectionMode = ['single', 'multiple'].includes(mode) ? mode : 'single';
                this.#dropdown.multiple = this.state.selectionMode === 'multiple';
                this.#syncOptionsWithSelect();
            }

            #parseOptions(optionsData) {
                if (!optionsData || !(typeof optionsData == 'string' && optionsData?.length > 0)) return this.#getDefaultOptions();
                try {
                    return optionsData
                        .trim()
                        .replace(/^[\[\]]/g, '')
                        .split(',')
                        .map(opt => {
                            const [value, text] = opt.includes(':')
                                ? opt.split(':').map(part => part.trim().replace(/'/g, ''))
                                : [opt.trim(), opt.trim()];
                            return { value, text };
                        });
                } catch {
                    return this.#getDefaultOptions();
                }
            }

            #getDefaultOptions() {
                if ((this.getAttribute('data-options') == null || this.getAttribute('data-options') == '' || this.getAttribute('data-options') == '[]' || this.getAttribute('data-options') == '""') || !this.getAttribute('data-options')) {
                    this.setAttribute('data-options', '[ : ]');
                    return [
                        { value: '', text: '' },
                        { value: 'Option1', text: 'Option 1' },
                        { value: 'Option2', text: 'Option 2' },
                        { value: 'Option3', text: 'Option 3' }
                    ];
                }
                else {
                    return this.#parseOptions(this.getAttribute('data-options'));
                };

            }

            #syncOptionsWithSelect() {
                if (!this.#dropdown) return;
                this.#dropdown.innerHTML = (this.state.options
                    .map(option => `<option value="${option.value}">${option.text}</option>`)
                    .join('').replace(']', '').replace('[', ''));
                this.#dropdown.value = this.state.value;

            }

            #handleTextInput(event = { target: this.#textbox }) {
                this.state.value = event.target.value;
                this.#announce(`Input updated to: ${this.state.value}`);
                this.dispatchEvent(new CustomEvent('input-changed', {
                    detail: { value: this.state.value },
                    bubbles: true,
                    composed: true,
                    view: null
                }));
            }

            #handleKeyPress(event = { key: 'Enter', target: this.#textbox }) {
                if (event.key === 'Enter' && this.#textbox.value.trim()) {
                    const value = this.#textbox.value;
                    if (!this.state.options.some(opt => opt.value === value)) {
                        this.state.options.push({ value, text: value });
                        this.#syncOptionsWithSelect();
                    }
                    this.#updateValue(value);
                    this.#announce(`Option added: ${value}`);
                    this.dispatchEvent(new CustomEvent('input-added', {
                        detail: { value: value },
                        bubbles: true,
                        composed: true,
                        view: null
                    }));
                }
            }

            #handleSelectChange(event = { target: this.#dropdown }) {
                if (event.target === this.#dropdown) {
                    this.state.value = event.target.value;
                    this.#updateValue(this.state.value);
                    this.#announce(`Selected option: ${this.state.value}`);
                    this.dispatchEvent(new CustomEvent('selection-changed', {
                        detail: { value: this.state.value },
                        bubbles: true,
                        composed: true,
                        view: null
                    }));
                }
            }


            #handleFocus(e = { target: this.#textbox }) {
                const t = e.target;
                const t2 = e.target == this.#textbox ? this.#dropdown : this.#textbox;
                if (t == this.#dropdown) {
                    t2.focus();
                }
                t.style.border = 'initial';
                t.style.outline = 'initial';
                t.style.boxShadow = 'initial';
                t2.style.border = 'initial';
                t2.style.outline = 'initial';
                t2.style.boxShadow = 'initial';
            }

            #updateValue(value) {
                if (this.state.selectionMode === 'multiple') {
                    if (Array.isArray(value)) {
                        this.state.value = value.join(',');
                    } else if (typeof value === 'string') {
                        this.state.value = value.split(',')
                            .map(v => v.trim())
                            .filter(v => v !== '')
                            .join(',');
                    }
                } else {
                    this.state.value = Array.isArray(value) ? value[0] : value;
                }

                this.setAttribute('data-value', this.state.value);
                this.setAttribute('data-options', JSON.stringify(this.state.options));

                if (this.#textbox) {
                    this.#textbox.value = this.state.value;
                }

                if (this.#dropdown) {
                    if (this.state.selectionMode === 'multiple') {
                        const values = this.state.value.split(',');
                        Array.from(this.#dropdown.options).forEach(option => {
                            option.selected = values.includes(option.value);
                        });
                    } else {
                        this.#dropdown.value = this.state.value;
                    }
                }

                if (!this.state.options.some(opt => opt.value === this.state.value)) {
                    this.state.options.push({ value: this.state.value, text: this.state.value });
                    this.#syncOptionsWithSelect();
                }
            }
            #updatePlaceholder(placeholder) {
                if (this.#textbox) this.#textbox.placeholder = placeholder;
                this.setAttribute('data-placeholder', placeholder);
            }

            announcementRegion = () => {
                const ar = document.createElement('p');

                ar.style = {
                    position: 'absolute',
                    overflow: 'hidden',
                    zIndex: '9999',
                    backgroundColor: '#f0f0f0dd'
                }
                document.body.appendChild(ar);
                return ar;
            }

            #announce(message) {
                if (this.announcementRegion) {
                    this.announcementRegion.textContent = message;
                }
            }

            #positionDropdown() {
                if (!this.#textbox || !this.#dropdown) return;
                const textboxRect = this.#textbox.getBoundingClientRect();
                const dropdownRect = this.#dropdown.getBoundingClientRect();
                const dropdownHeight = dropdownRect.height;
                const textboxHeight = textboxRect.height;
                const dropdownTop = textboxRect.bottom;
                const dropdownLeft = textboxRect.left;
                this.style.top = `${textboxRect.top}px`;
                this.style.left = `${dropdownLeft * textboxRect.left / 2}px`;
                if (this.style.height != this.#dropdown.style.height) {
                    this.#textbox.style.height = this.style.height;
                }
                if (this.style.height != this.#dropdown.style.height) {
                    this.#dropdown.style.height = this.#textbox.style.height;
                }
                if (this.#textbox.style.fontSize > this.style.height - this.#textbox.style.padding) {
                    this.#textbox.style.fontSize = this.style.height - this.#textbox.style.padding;
                }
            }

            #determineBrowser() {
                const userAgent = navigator?.userAgent;
                let codeName = 'Unknown';

                const browserPatterns = [
                    { pattern: "Chrome", name: "Google Chrome", excludes: ["Edge", "OPR"] },
                    { pattern: "Firefox", name: "Mozilla Firefox" },
                    { pattern: "Safari", name: "Safari", excludes: ["Chrome"] },
                    { pattern: "Edge", name: "Microsoft Edge" },
                    { pattern: ["OPR", "Opera"], name: "Opera" },
                    { pattern: ["MSIE", "Trident"], name: "Internet Explorer" }
                ];

                for (const browser of browserPatterns) {
                    const patterns = Array.isArray(browser.pattern) ? browser.pattern : [browser.pattern];
                    const hasPattern = patterns.some(pattern => userAgent.indexOf(pattern) > -1);
                    const noExcludes = !browser.excludes?.some(exclude => userAgent.indexOf(exclude) > -1);

                    if (hasPattern && noExcludes) {
                        codeName = browser.name;
                        break;
                    }
                }
                consolee.log(`Browser: ${codeName}    \n fuckinshitt355`);
                return codeName;
            }

            #browserSpecificStyleDefaults(ofName = 'Unknown') {
                const sets = {
                    'Google Chrome': (() => {
                        return {
                            border: '1px solid #ccc',
                            outline: 'none',
                            borderRadius: '4px',
                            // and so on, such as that the select, input, and containing elements in the custom elements' shadow DOM are rendered the same across browsers.
                        };
                    })(),
                    'Mozilla Firefox': (() => {
                        return {
                            border: '1px solid #ccc',
                            outline: 'none',
                            borderRadius: '4px',
                            // and so on, such as that the select, input, and containing elements in the custom elements' shadow DOM are rendered the same across browsers.
                        };
                    })(),
                    'Safari': (() => {
                        return {
                            border: '1px solid #ccc',
                            outline: 'none',
                            borderRadius: '4px',
                            // and so on, such as that the select, input, and containing elements in the custom elements' shadow DOM are rendered the same across browsers.
                        };
                    })(),
                    'Microsoft Edge': (() => {
                        return {
                            border: '1px solid #ccc',
                            outline: 'none',
                            borderRadius: '4px',
                            // and so on, such as that the select, input, and containing elements in the custom elements' shadow DOM are rendered the same across browsers.
                        };
                    })(),
                    'Opera': (() => {
                        return {
                            border: '1px solid #ccc',
                            outline: ''
                        }
                    })
                };
                const matchingBrowser = Object.keys(sets).find(setName =>
                    ofName.includes(setName) || setName.includes(ofName)
                );

                return matchingBrowser ? sets[matchingBrowser] : sets['Google Chrome'];
            }


            #setBrowserSpecificStyles() {
                const thisBrowser = this.#determineBrowser();
                const browserSpecificStyles = this.#browserSpecificStyleDefaults(thisBrowser);

                for (const [property, value] of Object.entries(browserSpecificStyles)) {
                    this.style[property] = value;
                }
            }
        }

        if (!customElements.get('combo-input')) {
        customElements.define('combo-input', CustomSelectInput);
        }
        if (add) {
            const el = document.createElement('combo-input');
            document.body.appendChild(el);
            return null;
        }

        return document.createElement('combo-input');
};
createCustomSelectInput(false);

class APIChatBox extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
            this.shadow = this.shadowRoot;
            this.apiKey = null;
            this.endpoint = 'https://api.openai.com/v1/chat/completions/';
            this.model = 'gpt-4o-mini';
            this.temperature = 0.7;
            this.top_p = 0.5;
            this.theme = 'custom';
            this.customtheme = {
                bgclr: '#090000',
                txtclr: '#000000',
                fontsz: '0.75rem'
            };
            this.messages = [];
            this.maxTokens = 250;
            this.max_tokens = this.maxTokens;
            this.render();
        }
        render() {
            const template = `
    <style> :host { display: block; max-width: 50vmin; max-height: 75vh; box-sizing: border-box; margin: 0 auto; background-color: #f0f0f0; border-radius: 8px; overflow: auto; font-family: Arial, sans-serif; } #container { display: flex; flex-direction: column; height: fit-content; max-width: 100%; margin: auto; border: 1px solid #ccc; border-radius: 8px; background-color: #990000; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); } .titlebar { display: flex; align-items: center; background-color: #007bff; color: white; padding: 10px; } .titlebar-group { display: flex; flex-grow: 1; } .menubtn { cursor: pointer; margin: 0 5px; padding: 8px 12px; border-radius: 4px; transition: background-color 0.3s; } .menubtn:hover { background-color: rgba(255, 0, 0, 0.4); } .bar-spacer { flex-grow: 1; } .collapsible { display: none; } .collapsible.active { display: block; } .dropdown { padding: 10px; border-top: 1px solid #ddd; } .settings-group { margin-bottom: 15px; } .settingsbtn { font-weight: bold; display: block; margin: 10px 0; } .theme-options, .api-inputs, .theme-actions { margin-top: 10px; } .theme-inputs span, .api-inputs span { display: flex; justify-content: space-between; margin: 5px 0; } .input-area { display: flex; padding: 10px; border-top: 1px solid #ddd; } .input-area input { flex-grow: 1; padding: 10px; border: 1px solid #ccc; border-radius: 4px; margin-right: 5px; } .input-area button { padding: 10px 15px; border: none; border-radius: 4px; background-color: #007bff; color: white; cursor: pointer; transition: background-color 0.3s; } .input-area button:hover { background-color: #0056b3; } .chat-container { flex-grow: 1; padding: 10px; overflow-y: auto; } .messages { max-height: calc(100vh - 200px); overflow-y: auto; margin-bottom: 10px; } .typing-indicator { color: #00990099; font-style: italic; } .help-container { padding: 15px; } @media (max-width: 600px) { #container { max-width: fit-content; border-radius: 0; } .input-area { flex-direction: column; } .input-area input { margin-bottom: 5px; } .input-area button { width: 100%; } } *.invisible { display: none;} *.visible {display: block;} * {color: black; } .panelbtn { max-width: fit-content; max-height: fit-content; padding: 1px; margin: 1px;} .panelbtns {display: flex; flex-direction: row; max-width: fit-content; max-height: fit-content; margin: 1%; padding: 0px;  }  </style>
    <div id="container" class="container" >
        <div id="titlebar" class="titlebar">
            <div class="titlebar-group">
                <span class="menubtn" id="chatbtn">Chat</span>
                <span class="bar-spacer"></span>
                <span id="settingsbtn" class="menubtn">Settings</span>
                <span class="bar-spacer"></span>
                <div class="panelbtns">
                    <span class="menubtn panelbtn" id="helpbtn" title="Show Help">?</span>
                    <button class="menubtn panelbtn" id="reset-button" title="Reset Layout">&olarr;</button>
                    <button class="menubtn panelbtn" id="minimize-button" title="Shrink">-</button>
                    <button class="menubtn panelbtn" id="maximize-button" title="Expand">+</button>
                    <button class="menubtn panelbtn" id="close-button" title="Remove">X</button>
                </div>
            </div>
        </div>

        <div id="settings-container" class="collapsible dropdown">
            <div class="settings-group">
                <span id="themesettingsbtn" class="settingsbtn menubtn">Theme</span>
                <div id="theme-select" class="collapsible dropdown collapsed">
                    <div class="theme-options">
                        <span class="light-theme" id="lightthemebtn">Light</span>
                        <span class="dark-theme" id="darkthemebtn">Dark</span>
                        <span style="background-image: linear-gradient(1deg, #000000 0%, #ffffff 100%)" id="customthemebtn">Custom</span>
                        <div id="customtheme" class="collapsible dropdown collapsed">
                            <div class="theme-inputs">
                                <span>Background Color:<input type="color" id="backgroundcolorinput" /></span>
                                <span>Text Color:<input type="color" id="textcolorinput" /></span>
                                <span>Font Size:<input type="number" increment="1" minimum="10" value="16" maximum="100" id="fontsizeinput" /></span>
                            </div>
                        </div>
                        <div class="theme-actions">
                            <span id="resetthemebtn">Reset</span>
                            <span id="savethemebtn">Save</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="settings-group">
                <span id="apisettingsbtn" class="settingsbtn menubtn">API</span>
                <div id="api-select" class="collapsible dropdown">
                    <div class="api-inputs">
                        <span>Key:<input type="text" id="apiKeyinput" /><button id="savekeybtn" class="inputbtn">Save</button></span>
                        <span>Organization:<input type="text" id="organizationinput" /></span>
                        <span>Endpoint:<input type="text" id="apiUrlinput" placeholder="default: https://api.openai.com/v1/chat/completions/" /></span>
                        <span>Model:<combo-input id="modelinput" data-options="[ : , gpt-4o, gpt-4o-mini, gpt-3.5-turbo]"></combo-input></span>
                        <span>Temperature:<input type="text" id="temperatureinput" placeholder="0.7" /></span>
                        <span class="tokens-input">
                            Max Tokens:<input type="number" increment="10" minimum="10" value="250" maximum="10000" id="max_tokensinput" />
                            <input type="range" id="max_tokens_range" min="10" max="10000" value="250" />
                            <span id="max_tokens_value">250</span>
                            <input style="display: none" type="text" placeholder="Token use limit per response, includes input tokens." id="max_tokens_text" />
                        </span>
                    </div>
                </div>
            </div>

            <div class="settings-group">
                <span id="convosettingsbtn" class="settingsbtn menubtn">Conversation</span>
                <div id="convosettings-container" class="collapsible dropdown">
                    <div class="convo-actions">
                        <span class="menubtn" id="newchatbtn">New Chat</span>
                        <span class="menubtn" id="clearchatbtn">Clear Chat</span>
                        <span class="menubtn" id="savechatbtn">Save Chat</span>
                        <span class="menubtn" id="chathistorybtn">History</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="container dropdown" id="chat-view">
            <div class="chat-container container" id="chat-container">
                <div class="messages" id="messages"></div>
                <div class="typing-indicator invisible"   id="typingIndicator">ChatGPT is typing...</div>
            </div>
            <div class="input-area">
                <input type="text" id="userInput" placeholder="Type your message..." />
                <button id="sendButton">Send</button>
            </div>
        </div>

        <div class="collapsible dropdown" id="help-view" style="max-width: 45vmin; overflow-y: auto;">
            <div class="help-container container">
                <h2>Help</h2>
                <p>Welcome to the ChatGPT ChatBox! Here are some tips to get started:</p>
                <ul>
                    <li>You need to enter your OpenAI API key in the settings to use the chatbox. 
To get a new one you can create an account on the <a href="https://www.openai.com">OpenAI API</a> website and follow their instructions to generate one.</li>
                    <li>You can customize the chatbox's appearance and behavior in the settings.</li>
                    <li>To start a new chat, click the "New Chat" button or close the extension panel and reopen it.</li>
                    <li>To clear the chat history, click the "Clear Chat" button.</li>
                </ul>
            </div>
        </div> 
        <drag-grip style="position: absolute; top: 0; right: 0; z-index: 1000; cursor: move;"></drag-grip>
    </div>

`;
            
            this.shadowRoot.innerHTML = template;
            const mi = this.shadow.querySelectorAll('combo-input');
            Array.from(mi).forEach(el => {
                if (el.id != 'modelinput'){
                    el.remove();
                }
            })

            this.setEventListeners();
        }

        setEventListeners() {

            function setClassTheme(theme) {
                const body = document.body;
                let hastheme = () => body.className.includes('-theme') ? true : false;
                function checkfortheme() {
                    if (hastheme()) {
                        body.className = body.className.replace(body.className.substring(body.className.lastIndexOf(' ', body.className.indexOf('-theme')), body.className.indexOf('-theme') + 6), '');
                    }
                    if (hastheme()) {
                        checkfortheme();
                    }
                }
                body.className += ` ${theme}-theme `;


            }


            // UI Control Elements
            const chatbtn = this.shadowRoot.getElementById('chatbtn');
            const chatView = this.shadowRoot.getElementById('chat-view');
            const settingsbtn = this.shadowRoot.getElementById('settingsbtn');
            const helpButton = this.shadowRoot.getElementById('helpbtn');
            const helpContainer = this.shadowRoot.getElementById('help-view');
            const resetButton = this.shadowRoot.getElementById('reset-button');
            const minimizeButton = this.shadowRoot.getElementById('minimize-button');
            const maximizeButton = this.shadowRoot.getElementById('maximize-button');
            const closeButton = this.shadowRoot.getElementById('close-button');
            const themeButton = this.shadowRoot.getElementById('themesettingsbtn');
            const themeselect = this.shadowRoot.getElementById('theme-select');
            const lightthemebtn = this.shadowRoot.getElementById('lightthemebtn');
            const darkthemebtn = this.shadowRoot.getElementById('darkthemebtn');
  //            const systemthemebtn = this.shadowRoot.getElementById('systemthemebtn');
            const customthemebtn = this.shadowRoot.getElementById('customthemebtn');
            const customtheme = this.shadowRoot.getElementById('customtheme');
            const resetthemebtn = this.shadowRoot.getElementById('resetthemebtn');
            const savethemebtn = this.shadowRoot.getElementById('savethemebtn');
            const backgroundcolorinput = this.shadowRoot.getElementById('backgroundcolorinput');
            const textcolorinput = this.shadowRoot.getElementById('textcolorinput');
            const fontsizeinput = this.shadowRoot.getElementById('fontsizeinput');
            const apiSettingsbtn = this.shadowRoot.getElementById('apisettingsbtn');
            const apiKeyinput = this.shadowRoot.getElementById('apiKeyinput');
            const saveKeybtn = this.shadowRoot.getElementById('savekeybtn');
            const modelinput = this.shadowRoot.getElementById('modelinput');
            const temperatureinput = this.shadowRoot.getElementById('temperatureinput');
            const max_tokensinput = this.shadowRoot.getElementById('max_tokensinput');
            const max_tokens_range = this.shadowRoot.getElementById('max_tokens_range');
            const max_tokens_value = this.shadowRoot.getElementById('max_tokens_value');
            const max_tokens_text = this.shadowRoot.getElementById('max_tokens_text');
            const convoSettingsbtn = this.shadowRoot.getElementById('convosettingsbtn');
            const convoSettingsContainer = this.shadowRoot.getElementById('convosettings-container');
            const sendButton = this.shadowRoot.getElementById('sendButton');
            const userInput = this.shadowRoot.getElementById('userInput');
            const panel = this.shadowRoot.getElementById('container');
            const ttlbr = this.shadowRoot.getElementById('titlebar');
            const elements = this.shadowRoot.querySelectorAll('input, div, span, button, input, drag-grip, textarea, body, html, p, ul, li, h2');
            const panelbtns = this.shadowRoot.querySelectorAll('.panelbtn');
            const elementsDisplayValuesMap = new Map(
                Array.from(elements).map(element => [
                    element.id || `${element.tagName}-${Array.from(elements).indexOf(element)}`,
                    getComputedStyle(element).display
                ])
            );

            const toggleElementDisplay = (element, show) => {
                const elementId = element.id || `${element.tagName}-${Array.from(elements).indexOf(element)}`;
                element.style.display = show ? elementsDisplayValuesMap.get(elementId) : 'none';
                if (!element.style.display || element.style.display === 'null') {
                    element.style.display = 'block';
                }
            };

            const toggleElementsDisplay = show => {
                elements.forEach(element => toggleElementDisplay(element, show));
            };

            const minimize = () => {
                toggleElementsDisplay(false);
                [panel, ttlbr].forEach(element => toggleElementDisplay(element, true));
                panelbtns.forEach(btn => btn.style.display = 'block');
                minimizeButton.style.display = 'none';
                minimizeButton.parentElement.style.display = 'block';
                [maximizeButton, closeButton].forEach(btn => toggleElementDisplay(btn, true));
                toggleElementDisplay(ttlbr.firstElementChild, true);
                this.shadowRoot.querySelector('drag-grip').style.display = 'block';
            };

            const maximize = () => {
                toggleElementsDisplay(true);
                [panel, ttlbr].forEach(element => toggleElementDisplay(element, true));
                ttlbr.style.display = 'flex';
                ttlbr.style.flexDirection = 'row';
                ttlbr.firstElementChild.style.display = 'flex';
                ttlbr.firstElementChild.style.flexDirection = 'row';

                maximizeButton.style.display = 'none';
            };

            const reset = () => {
                const nt = Object.assign(Contract.chat(), this);
                nt.messages = [];
                this.messages.forEach(m => {
                    let cls = m.sender == 'user' ? 'user-message' : 'chatgpt-message';
                    nt.addMessage(m.sender, m.message, cls);
                });
                this.remove();
            }

            const closeBox = () => {
                this.remove();
            };

            resetButton.addEventListener('click', reset);
            minimizeButton.addEventListener('click', minimize);
            maximizeButton.addEventListener('click', maximize);
            closeButton.addEventListener('click', closeBox);
            chatbtn.addEventListener('click', () => {
                chatView.style.display = chatView.style.display === 'none' ? 'block' : 'none';
            });

            settingsbtn.addEventListener('click', () => {
                const settingsContainer = this.shadowRoot.getElementById('settings-container');
                settingsContainer.style.display = settingsContainer.style.display === 'none' ? 'block' : 'none';
            });

            helpContainer.style.display = 'none';
            helpButton.addEventListener('click', () => {
                helpContainer.style.display = helpContainer.style.display === 'none' ? 'block' : 'none';
            });

            themeButton.addEventListener('click', () => {
                themeselect.style.display = themeselect.style.display === 'none' ? 'block' : 'none';
            });

            convoSettingsbtn.addEventListener('click', () => {
                convoSettingsContainer.style.display = convoSettingsContainer.style.display === 'none' ? 'block' : 'none';
            });

            lightthemebtn.addEventListener('click', () => {
                setClassTheme('light');
                Array.from(this.shadowRoot.querySelectorAll('div', 'span', 'input', 'label')).forEach(element => {
                    if (element.tagName === 'SPAN') {
                        element.style.borderColor = '#090909';
                        element.style.boxShadow = '1px 0px 10px 0px ' + '#005599';
                    }
                    element.style.color = 'black';
                    element.style.backgroundColor = 'white';
                    element.style.borderColor = '#005599';
                });
                Contract.data().secureStore('theme', 'light');
            });

            darkthemebtn.addEventListener('click', () => {
                const body = document.body;
                setClassTheme('dark');
                Contract.data().secureStore('theme', 'dark');
                Array.from(this.shadowRoot.querySelectorAll('div', 'span', 'input', 'label')).forEach(element => {
                    if (element.tagName === 'SPAN') {
                        element.style.borderColor = '#090909';
                        element.style.borderWidth = '1px';
                        element.style.boxShadow = '1px 1px 10px 1px ' + '#005599';
                    }
                    element.style.color = 'white';
                    element.style.backgroundColor = 'black';
                    element.style.borderColor = 'grey';
                });

            });

            customthemebtn.addEventListener('click', () => {
                customtheme.style.display = customtheme.style.display === 'none' ? 'block' : 'none';
                customtheme.querySelectorAll('input').forEach(input => {
                    if (input.type == 'color') {
                        if (input.id === 'backgroundcolorinput') {
                            input.addEventListener('input', (e) => {
                                this.customtheme.bgclr = input.value;
                                Contract.data().secureStore('customtheme', JSON.stringify(this.customtheme));

                            });
                        } else if (input.id === 'textcolorinput') {
                            input.addEventListener('input', (e) => {
                                this.customtheme.txtclr = input.value;
                                Contract.data().secureStore('customtheme', JSON.stringify(this.customtheme));

                            });
                        }
                    }
                    if (input.type == 'text')
                        input.addEventListener('input', (e) => {
                            this.customtheme.fontsz = input.value + 'px';
                            Contract.data().secureStore('customtheme', JSON.stringify(this.customtheme));

                        });
                    if (input.type == 'number') {
                        input.addEventListener('input', (e) => {
                            this.customtheme.fontsz = input.value + 'px';
                            Contract.data().secureStore('customtheme', JSON.stringify(this.customtheme));

                        });
                    }
                    Contract.data().secureStore('customtheme', JSON.stringify(this.customtheme));
                    [...this.shadowRoot.querySelectorAll('div', 'span')].forEach(element => {
                        if (element.tagName === 'SPAN') {
                            element.style.borderColor = this.customtheme.txtclr;
                            element.style.boxShadow = '1px 0px 10px 0px ' + this.customtheme.txtclr;

                        }
                        element.style.color = this.customtheme.txtclr;
                        element.style.backgroundColor = this.customtheme.bgclr;
                        element.style.fontSize = this.customtheme.fontsz;
                    });


                });
            });

            // API Settings Listeners
            apiSettingsbtn.addEventListener('click', () => {
                const apiSettingsContainer = this.shadowRoot.getElementById('api-select');
                apiSettingsContainer.style.display = apiSettingsContainer.style.display === 'none' ? 'block' : 'none';
            });

            function apikeylisteners() {
                apiKeyinput.addEventListener('input', (e) => {
                    apiKeyinput.focus();
                    const apiKey = apiKeyinput.value;
                });

                apiKeyinput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        if (apiKeyinput.value === '') {
                            alert('Please enter your API key.');
                            apiKeyinput.focus();
                            return;
                        }
                        const storedKey = Contract.data().secureRetrieve('apiKey');
                        if (!storedKey) {
                            Contract.data().secureStore('apiKey', apiKeyinput.value);
                            return true;
                        }
                        if (storedKey === apiKeyinput.value) {
                            return true;
                        }
                        if (storedKey !== apiKeyinput.value) {
                            const ync = confirm("Are you sure you want to save this API key?\
This will overwrite your current API key.");
                            if (ync) {
                                Contract.data().secureStore('apiKey', apiKeyinput.value);
                                return true;
                            }
                            if (!ync) {
                                return false;
                            }
                        }
                    }
                });

                saveKeybtn.addEventListener('click', () => {
                    if (apiKeyinput.value === '') {
                        alert('Please enter your API key.');
                        apiKeyinput.focus();
                        return;
                    }
                    const storedKey = Contract.data().secureRetrieve('apiKey');
                    if (!storedKey) {
                        Contract.data().secureStore('apiKey', apiKeyinput.value);
                        return true;
                    }
                    if (storedKey === apiKeyinput.value) {
                        return true;
                    }
                    if (storedKey !== apiKeyinput.value) {
                        const ync = confirm("Are you sure you want to save this API key?\
This will overwrite your current API key.");
                        if (ync) {
                            Contract.data().secureStore('apiKey', apiKeyinput.value);
                            return true;
                        }
                        if (!ync) {
                            return false;
                        }
                    }
                });

            }
            apikeylisteners();

            modelinput.addEventListener('input', () => {
                const model = modelinput.value;
                Contract.data().secureStore('model', model);
                this.model = model;
            });

            temperatureinput.addEventListener('input', () => {
                const temperature = temperatureinput.value;
                Contract.data().secureStore('temperature', temperature);
                this.temperature = temperature;
            });




            max_tokens_range.addEventListener('input', () => {
                let max_tokens = max_tokens_range.value;
                this.rangeTimeout = setTimeout(() => {
                    if (max_tokens != max_tokens_range.value) {
                        clearTimeout(this.rangeTimeout);
                        return;
                    }
                    max_tokensinput.value = max_tokens;
                    max_tokens = max_tokens_range.value;
                    Contract.data().secureStore('max_tokens', max_tokens);
                    this.maxTokens = parseInt(max_tokens);
                    max_tokens_value.textContent = max_tokens;
                    max_tokens_text.placeholder = max_tokens;
                }, 500);
            });

            max_tokensinput.addEventListener('input', () => {
                const max_tokens = max_tokensinput.value;
                Contract.data().secureStore('max_tokens', max_tokens);
                this.maxTokens = parseInt(max_tokens);
                max_tokens_range.value = parseInt(max_tokens);
                max_tokens_value.textContent = max_tokens;
                max_tokens_text.placeholder = max_tokens;
            });


            // Chat Input Listeners
            sendButton.addEventListener('click', () => this.sendMessage());
            userInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    this.sendMessage();
                }
            });
        }



        initializeEventListeners() {
            const sendButton = this.shadowRoot.getElementById('sendButton');
            const userInput = this.shadowRoot.getElementById('userInput');
            sendButton.addEventListener('click', () => this.sendMessage());
            userInput.addEventListener('keypress', (e) => {

                if (e.key === 'Enter') {
                    this.sendMessage();
                }
            });

            userInput.addEventListener('input', () => {
                sendButton.disabled = !userInput.value.trim();
            });
        }

        async sendMessage() {
            if (this.isProcessing) return;

            const inputField = this.shadowRoot.getElementById('userInput');
            const sendButton = this.shadowRoot.getElementById('sendButton');
            const message = inputField.value.trim();

            if (!message) return;

            this.isProcessing = true;
            sendButton.disabled = true;
            inputField.value = '';

            this.addMessage('User', message, 'user-message');
            this.showTypingIndicator(true);

            try {
                const response = await this.fetchResponse(message);
                this.addMessage('ChatGPT', response, 'bot-message');
            } catch (error) {
                this.addMessage('System', `${JSON.stringify(error)} ` + 'An error occurred while processing your message.', 'bot-message');
            } finally {
                this.isProcessing = false;
                sendButton.disabled = false;
                this.showTypingIndicator(false);
            }
        }

        addMessage(sender, message, className) {
            const messagesContainer = this.shadowRoot.getElementById('messages');
            const messageElement = document.createElement('div');
            messageElement.classList.add('message', className);
            messageElement.textContent = `${sender}: ${message}`;
            messagesContainer.appendChild(messageElement);
            this.messages.push({ sender, message });
            messageElement.scrollIntoView({ behavior: 'smooth' });
        }

        showTypingIndicator(vis = true) {
            if (vis === null || vis === undefined || (vis !== true && vis !== false)) {
                return;
            }
            if (vis) {
                this.shadowRoot.querySelector("#typingIndicator").className = 'visible';
            } else {
                this.shadowRoot.querySelector("#typingIndicator").className = 'invisible';
            }
        }

        setmaxTokens(value) {
            this.maxTokens = parseInt(value);
        }
        setModel(value) {
            this.model = value;
        }
        setApiKey(value) {
            Contract.data().secureStore('apiKey', value);
        }


        async fetchResponse(message) {
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${Contract.data().secureRetrieve('apiKey')}`
                    },
                    body: JSON.stringify({
                        model: this.model,
                        messages: [
                            ...this.getContextMessages(),
                            { role: 'user', content: message }
                        ],
                        temperature: 0.5,
                        max_tokens: this.maxTokens,
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                return data.choices[0].message.content;
            } catch (error) {
                console.error('Error fetching response:', error);
                throw error;
            }
        }

        getApiKey() {
            const oldKey = function () {
                try {
                    const storedKey = Contract.data().secureRetrieve('apiKey');
                    if (storedKey && typeof storedKey === 'string') {
                        return storedKey;
                    }
                    return null;
                } catch (error) {
                    console.error('Error retrieving API key:', error);
                    return null;
                }
            };

            let key = oldKey();
            if (!key) {
                const getKey = function () {
                    const k = `your hardcoded openai api key here, because I can't pay for everyone.`;
                    let t = function (e) {
                        return e;
                    };
                    return t(k);
                };
                const k = getKey();
                if (k) {
                    Contract.data().secureStore('apiKey', k);
                    this.apiKey = k;
                }
            }

            if (typeof key === 'string' && key.length > 0) {
                if (!this.apiKey || typeof this.apiKey !== 'string') {
                    Contract.data().secureStore('apiKey', key);
                    this.apiKey = key;
                }
                return key;
            }

            try {
                const storedKey = Contract.data().secureRetrieve('apiKey');
                if (storedKey && typeof storedKey === 'string') {
                    this.apiKey = storedKey;
                    return storedKey;
                }
            } catch (error) {
                console.error('Error retrieving API key:', error);
            }
            // Implement secure API key management

            this.apiKey.addEventListener('change', () => {
                Contract.data().secureStore('apiKey', this.apiKey);
            });
            this.apiKey = getKey();
            return this.apiKey;
        }




        getContextMessages() {
            // Return last few messages for context
            return this.messages.slice(-5).map(msg => ({
                role: msg.sender.toLowerCase() === 'user' ? 'user' : 'assistant',
                content: msg.message
            }));
        }

        static get observedAttributes() {
            return ['placeholder', 'theme'];
        }

        static create(apiKey, placeholder = 'Type your message...', theme = 'light') {
            const chatbox = document.createElement('api-chat-box');
            let clscbx = new APIChatBox();
            if (placeholder) chatbox.setAttribute('placeholder', placeholder);
            if (theme) chatbox.setAttribute('theme', theme);
            return chatbox;
        }

        connectedCallback() {
            this.getApiKey();
            this.style.position = 'fixed';
            this.style.left = '5px';
            this.style.top = '5px';
            this.style.zIndex = `${Number.MAX_SAFE_INTEGER}`;
        }

        disconnectedCallback() {
            Object.freeze(this);
        }
        attributeChangedCallback(name, oldValue, newValue) {
            if (name === 'api-key') {
                this.apiKey = newValue;
            } else if (name === 'placeholder') {
                this.placeholder = newValue;
            } else if (name === 'theme') {
                this.theme = newValue;
            }
        }

        static chat() {
            const chatbox = document.createElement('api-chat-box');
            chatbox.setAttribute('api-key', 'your hardcoded openai api key here, because I can\'t pay for everyone.');
            chatbox.setAttribute('placeholder', 'Type your message...');
            chatbox.setAttribute('theme', 'light');
            document.body.appendChild(chatbox);
            return chatbox;
        }
    }
    class Contract {
        constructor() {
        }

        static chat() {
            const chatbox = this.createChatBox();
            this.addToDom(chatbox);
            return chatbox;
        }

        static createChatBox(apiKey = null, placeholder = null, theme = null) {
            const chatbox = document.createElement('api-chat-box');
            const attributes = { 'api-key': 'not so fast', placeholder, theme };

            Object.entries(attributes)
                .filter(([_, value]) => value !== null)
                .forEach(([key, value]) => chatbox.setAttribute(key, value));

            return chatbox;
        }

        static addToDom(chatbox, target = document.body) {
            const container = this.findContainer(target);
            container.appendChild(chatbox);
            return chatbox;
        }

        static findContainer(target) {
            if (!target) return document.body;
            if (target.selector) return document.querySelector(target.selector) || document.body;
            if (target.firstmatch?.loc && target.firstmatch?.val) {
                return Array.from(document.querySelectorAll("*"))
                    .find(element => this.matchesElement(element, target.firstmatch)) || document.body;
            }
            return target instanceof HTMLElement ? target : document.body;
        }

        static matchesElement(element, match) {
            const loc = element[match.loc];
            return loc && (
                loc === match.val ||
                (loc.includes && loc.includes(match.val)) ||
                element === match.val ||
                (element.includes && element.includes(match.val))
            );
        }

        static data() {
            //handle local and secure data storage
            const storage = {
                set: (key, value) => {
                    try {
                        const encryptedValue = btoa(JSON.stringify(value));
                        window.localStorage.setItem(key, encryptedValue);
                        return true;
                    } catch (error) {
                        console.error('Error storing data:', error);
                        return false;
                    }
                },

                get: (key) => {
                    try {
                        const value = localStorage.getItem(key);
                        return value ? JSON.parse(atob(value)) : null;
                    } catch (error) {
                        console.error('Error retrieving data:', error);
                        return null;
                    }
                },

                remove: (key) => {
                    try {
                        localStorage.removeItem(key);
                        return true;
                    } catch (error) {
                        console.error('Error removing data:', error);
                        return false;
                    }
                },

                clear: () => {
                    try {
                        localStorage.clear();
                        return true;
                    } catch (error) {
                        console.error('Error clearing data:', error);
                        return false;
                    }
                },

                secureStore: (key, value) => {
                    const timestamp = Date.now();
                    const data = {
                        value,
                        timestamp,
                        expires: timestamp + (24 * 60 * 60 * 1000) // 24 hours
                    };
                    return storage.set(key, data);
                },

                secureRetrieve: (key) => {
                    const data = storage.get(key);
                    if (!data) return null;

                    if (Date.now() > data.expires) {
                        storage.remove(key);
                        return null;
                    }

                    return data.value;
                }
            };
            return storage;
        }
        static async fetch(url, options = {}) {
            const response = await fetch(url, options);
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
        }
        static async post(url, data) {
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });
            if (!response.ok) {
                Contract.foulball(url, JSON.stringify(data), 'system', 'invalid response for POST fetch', response);
               // throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
        }
        static async put(url, data) {
            const response = await fetch(url, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });
            if (!response.ok) {

                return Contract.foulball('server', 'client', 'system', 'invalid response', response);
            }
                if(!response.ok) {
                    // throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return response.json();
        }

        static foulball(pitcher, batter, referee, basis, r){ 
            const te = new Error(`${referee} says ${pitcher} threw foul ball to ${batter} and ${basis} rules ${r}`); 
                    te.response = r;
                    console.error(te);
                    console.log('foulball r : ', r);
                    console.log('foulball te : ', te);
                    return (() => {throw te})();
                };
        
    }
    class Grip extends HTMLElement {
        constructor() {
            super();
            this.isDragging = false;
            this.isGrippped = false;
            this.parent = null;
            this.initialMousePosition = { x: 0, y: 0 };
            this.initialParentPosition = { x: 0, y: 0 };
            this.boundMouseDown = this.onMouseDown.bind(this);
            this.boundMouseMove = this.onMouseMove.bind(this);
            this.boundMouseUp = this.onMouseUp.bind(this);
            this.boundTouchStart = this.waitForSecondTouchonTouchStart.bind(this);
            this.boundSecondTouch = this.waitForSecondTouch.bind(this);
            this.boundTouchEnd = this.onTouchEnd.bind(this);
        }

        connectedCallback() {
            this.style.cursor = 'grab';
            this.style.display = 'inline-flex';
            this.style.backgroundColor = 'skyblue';
            this.style.padding = '0.1rem';
            this.style.userSelect = 'none';
            this.style.position = 'relative';
            this.style.top = '0px';
            this.style.left = '0px';
            this.style.width = 'fit-content';
            this.style.minWidth = '0.5rem';
            this.style.maxWidth = 'fit-content';
            this.style.height = 'fit-content';
            this.style.minHeight = '0.5rem';
            this.style.maxHeight = 'fit-content';
            this.textContent = ':+:';
            this.title = 'Move me anywhere on the page\nJust click and drag,\nOr\nTap here, then tap where you want me to go';
            this.style.color = '#0009ff';
            this.style.fontSize = '0.75rem';
            this.style.zIndex = '9999';
            this.style.borderRadius = '0.25rem';
            this.style.border = '1px solid #0009ff';
            this.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
            this.style.transition = 'all 0.3s ease';
            this.parent = this.offsetParent;
            this.addEventListener('mousedown', this.boundMouseDown);
            this.addEventListener('touchstart', this.boundTouchStart);
        }

        disconnectedCallback() {
            this.removeEventListener('mousedown', this.boundMouseDown);
            document.removeEventListener('mousemove', this.boundMouseMove);
            document.removeEventListener('mouseup', this.boundMouseUp);
        }

        #MouseDown(e) {
            e.preventDefault();
            this.initialMousePosition.x = e.clientX;
            this.initialMousePosition.y = e.clientY;
            this.style.cursor = 'grabbing';
            this.isGrippped = true;
            const parent = this.offsetParent;
            this.parent = parent;
            if (parent) {
                const currentLeft = parent.style.left ? parseInt(parent.style.left) : parent.offsetLeft;
                const currentTop = parent.style.top ? parseInt(parent.style.top) : parent.offsetTop;

                this.initialParentPosition.x = currentLeft;
                this.initialParentPosition.y = currentTop;
            }

            document.addEventListener('mousemove', this.boundMouseMove);
            document.addEventListener('mouseup', this.boundMouseUp);
        }

        onMouseDown(e) {
            e.preventDefault();
            if (this.isDragging || this.isGrippped) {
                this.onMouseUp(e);
            }
            else {
                this.#MouseDown(e);
            }
        }

        #coderecyclebin = `
          e.preventDefault();
          this.isDragging = true;
          this.initialMousePosition.x = e.clientX;
          this.initialMousePosition.y = e.clientY;
          this.style.cursor = 'grabbing';
          const parent = this.parentElement;
          if (parent) {
              this.initialParentPosition.x = parent.style.left || parent.offsetLeft;
              this.initialParentPosition.y = parent.style.top || parent.offsetTop;
              parent.style.position = 'absolute';
              parent.style.zIndex = '9999';
              parent.style.top = \`\${this.initialParentPosition.y}px\`;
              parent.style.left = \`\${this.initialParentPosition.x}px\`;
          }
          document.addEventListener('mousemove', this.boundMouseMove);
          document.addEventListener('mouseup', this.boundMouseUp);
      }`;

        onMouseMove(e) {
            if (!this.isGrippped) return;
            this.isDragging = true;
            const deltaX = e.clientX - this.initialMousePosition.x;
            const deltaY = e.clientY - this.initialMousePosition.y;
            const newX = this.initialParentPosition.x + deltaX;
            const newY = this.initialParentPosition.y + deltaY;
            const viewW = parseInt(this.offsetParent.parentElement.style.width);
            const viewH = window.visualViewport.height;
            const parent = this.offsetParent;

            if (parent) {
                if (parent.style.position !== 'absolute') {
                    parent.style.position = 'absolute';

                }
                parent.style.maxWidth = 'fit-content';
                parent.style.maxHeight = 'fit-content';
                const container = parent.shadowRoot.getElementById('container');
                const containerWidth = parseInt(container.style.width);
                const containerHeight = parseInt(container.style.height);
                parent.style.width = `${containerWidth}px`;
                parent.style.height = `${containerHeight}px`;
                parent.style.left = `${newX}px`;
                parent.style.top = `${newY}px`;
                if (parseInt(parent.offsetLeft) > viewW - parseInt(parent.style.width) || parseInt(parent.style.right) < 1) {
                    parent.style.right = '1px';
                }
                if (parseInt(parent.style.left) < 0) {
                    parent.style.left = '0px';
                };
                if (parseInt(parent.style.bottom) < containerHeight) {
                    parent.style.bottom = '0px';
                    parent.style.top = e.clientY - (containerHeight / 2) + 'px';
                };
                if (parseInt(parent.style.top) < 0) {
                    parent.style.top = '0px';
                };
                parent.style.zIndex = `${parseInt(Number.MAX_SAFE_INTEGER)}`;
                Array.from(document.querySelector("api-chat-box")?.shadowRoot?.querySelector("#titlebar")?.children).forEach(child => {
                    if (child.id === "titlebar") return;
                    if (child.className.includes('menubtn')) {
                        child.style.zIndex = `${parseInt(Number.MAX_SAFE_INTEGER)}`;
                        child.style.display = "inline-flex";
                        child.style.position = "relative";
                        child.style.top = "0px";
                        child.style.left = "0px";
                        child.style.width = "fit-content";
                        child.style.minWidth = "0.5rem";
                        child.style.maxWidth = "fit-content";
                        child.style.height = "fit-content";
                        child.style.minHeight = "0.5rem";
                        child.style.maxHeight = "fit-content";
                        child.style.color = "#0009ff";
                        child.style.fontSize = "0.75rem";
                        child.style.zIndex = "9999";
                        child.style.borderRadius = "0.25rem";
                        child.style.border = "1px solid #0009ff";
                        child.style.boxShadow = "0 2px 4px rgba(0, 0, 0, 0.1)";
                    }
                });
            }
        }

        onMouseUp() {
            if (this.isDragging || this.isGrippped) {
                this.isDragging = false;
                this.isGrippped = false;
                this.style.cursor = 'grab';
                this.parent.style.position = 'fixed';
                document.removeEventListener('mousemove', this.boundMouseMove);
                document.removeEventListener('mouseup', this.boundMouseUp);
            }
        }

        waitForSecondTouchonTouchStart(e) {
            e.preventDefault();
            if (!this.isGrippped) {
                this.initialMousePosition = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
                this.isGrippped = true;
                const parent = this.offsetParent;
                this.parent = parent;

                if (parent) {
                    const currentLeft = parent.style.left ? parseInt(parent.style.left) : parent.offsetLeft;
                    const currentTop = parent.style.top ? parseInt(parent.style.top) : parent.offsetTop;
                    this.initialParentPosition = {
                        x: currentLeft,
                        y: currentTop
                    };
                }

                this.removeEventListener('touchstart', this.boundTouchStart);
                document.addEventListener('touchstart', this.waitForSecondTouch.bind(this), { passive: false });
            }
        }

        waitForSecondTouch(e) {
            e.preventDefault();
            if (this.isGrippped && e.touches.length > 1) {
                const secondTouchPosition = {
                    x: e.touches[1].clientX,
                    y: e.touches[1].clientY
                };

                const deltaX = secondTouchPosition.x - this.initialMousePosition.x;
                const deltaY = secondTouchPosition.y - this.initialMousePosition.y;
                const newX = this.initialParentPosition.x + deltaX;
                const newY = this.initialParentPosition.y + deltaY;

                this.updateParentPosition(newX, newY);

                this.isGrippped = false;
                document.removeEventListener('touchstart', this.waitForSecondTouch);
                this.addEventListener('touchstart', this.boundTouchStart);
            }
        }

        updateParentPosition(newX, newY) {
            const parent = this.parent;
            parent.style.maxWidth = 'fit-content';
            parent.style.maxHeight = 'fit-content';

            const container = parent.shadowRoot.getElementById('container');
            const containerWidth = parseInt(container.style.width);
            const containerHeight = parseInt(container.style.height);

            parent.style.width = `${containerWidth}px`;
            parent.style.height = `${containerHeight}px`;
            parent.style.left = `${newX}px`;
            parent.style.top = `${newY}px`;
            parent.style.right = `calc(100vw - ${newX + containerWidth}px)`;
            parent.style.right = Math.max(5, parent.style.right);
            parent.style.width = `${containerWidth}px`;
            parent.style.bottom = `calc(100vh - ${newY + containerHeight}px)`;
            parent.style.zIndex = `${parseInt(Number.MAX_SAFE_INTEGER)}`;
        }

        #touchend(e) {
            this.isGrippped = false;
            this.parent.style.position = 'fixed';
        }

        onTouchEnd(e) {
            e.preventDefault();
            if (this.isGrippped) {
                this.#touchend(e);
            }
        }
    }


    customElements.define('drag-grip', Grip);
    customElements.define('api-chat-box', APIChatBox);
    Contract.chat();


    window.APIChatBox = APIChatBox;
    window.Contract = Contract;
}
        </script>
    </body>
</html>
